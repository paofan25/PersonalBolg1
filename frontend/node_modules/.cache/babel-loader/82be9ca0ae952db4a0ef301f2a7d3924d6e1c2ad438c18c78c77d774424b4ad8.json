{"ast":null,"code":"import \"core-js/modules/web.dom-exception.stack.js\";\nimport CryptoJS from 'crypto-js';\n\n/**\n * 讯飞星火大模型服务\n */\nclass SparkService {\n  constructor() {\n    // 应用配置\n    this.appId = 'your_app_id';\n    this.apiKey = 'your_api_key';\n    this.apiSecret = 'your_api_secret';\n    this.apiUrl = 'wss://spark-api.xf-yun.com/v3.5/chat';\n  }\n\n  /**\n   * 生成鉴权URL\n   * @returns {string} 带鉴权信息的WebSocket URL\n   */\n  genAuthUrl() {\n    // 鉴权参数\n    const host = this.parseApiUrl(this.apiUrl).host;\n    const path = this.parseApiUrl(this.apiUrl).path;\n    const date = new Date().toUTCString();\n    const algorithm = 'hmac-sha256';\n    const headers = 'host date request-line';\n    const signatureOrigin = `host: ${host}\\ndate: ${date}\\nGET ${path} HTTP/1.1`;\n\n    // 使用HMAC-SHA256进行签名\n    const signatureSha = CryptoJS.HmacSHA256(signatureOrigin, this.apiSecret);\n    const signature = CryptoJS.enc.Base64.stringify(signatureSha);\n\n    // 拼接鉴权信息\n    const authorizationOrigin = `api_key=\"${this.apiKey}\", algorithm=\"${algorithm}\", headers=\"${headers}\", signature=\"${signature}\"`;\n    const authorization = btoa(authorizationOrigin);\n\n    // 构建URL\n    const url = `${this.apiUrl}?authorization=${authorization}&date=${date}&host=${host}`;\n    console.log('已生成鉴权URL:', url);\n    return url;\n  }\n\n  /**\n   * 解析API URL\n   * @param {string} url 完整的API URL\n   * @returns {object} 包含host和path的对象\n   */\n  parseApiUrl(url) {\n    const urlObj = new URL(url);\n    return {\n      host: urlObj.host,\n      path: urlObj.pathname\n    };\n  }\n\n  /**\n   * 发送消息到星火大模型\n   * @param {string} message 用户消息\n   * @param {string} emotion 情感状态\n   * @returns {Promise<string>} 返回AI回复的内容\n   */\n  sendMessage(message, emotion = 'neutral') {\n    return new Promise((resolve, reject) => {\n      try {\n        // 生成鉴权URL\n        const authUrl = this.genAuthUrl();\n        console.log('正在连接星火大模型WebSocket...');\n\n        // 创建WebSocket连接\n        const ws = new WebSocket(authUrl);\n\n        // 拼接请求参数\n        const prompt = this.formatPrompt(message, emotion);\n        const requestData = {\n          header: {\n            app_id: this.appId,\n            uid: 'user_001'\n          },\n          parameter: {\n            chat: {\n              domain: 'generalv3.5',\n              max_tokens: 1024,\n              temperature: 0.7\n            }\n          },\n          payload: {\n            message: {\n              text: [{\n                role: 'user',\n                content: prompt\n              }]\n            }\n          }\n        };\n\n        // 缓存返回结果\n        let finalResponse = '';\n\n        // 监听WebSocket事件\n        ws.onopen = () => {\n          console.log('WebSocket连接已打开，正在发送请求...');\n          ws.send(JSON.stringify(requestData));\n        };\n        ws.onmessage = event => {\n          try {\n            const response = JSON.parse(event.data);\n            console.log('收到WebSocket响应:', response);\n\n            // 检查是否有错误\n            if (response.header.code !== 0) {\n              console.error('星火API返回错误:', response.header.message);\n              ws.close();\n              reject(new Error(`星火API错误: ${response.header.message}`));\n              return;\n            }\n\n            // 获取回答内容\n            if (response.payload && response.payload.choices && response.payload.choices.text) {\n              const content = response.payload.choices.text[0].content;\n              finalResponse += content;\n            }\n\n            // 判断是否结束\n            if (response.header.status === 2) {\n              ws.close();\n              console.log('WebSocket会话完成，收到完整回复');\n              resolve(finalResponse);\n            }\n          } catch (parseError) {\n            console.error('解析WebSocket消息出错:', parseError);\n            ws.close();\n            reject(parseError);\n          }\n        };\n        ws.onerror = error => {\n          console.error('WebSocket连接错误:', error);\n          reject(new Error('WebSocket连接出错'));\n        };\n        ws.onclose = () => {\n          console.log('WebSocket连接已关闭');\n          if (!finalResponse) {\n            reject(new Error('WebSocket连接意外关闭，未收到有效回复'));\n          }\n        };\n\n        // 设置超时\n        setTimeout(() => {\n          if (ws.readyState === WebSocket.OPEN) {\n            console.log('WebSocket请求超时，强制关闭');\n            ws.close();\n            reject(new Error('请求超时，未收到完整回复'));\n          }\n        }, 10000);\n      } catch (error) {\n        console.error('发送消息过程中出错:', error);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * 格式化提示词\n   * @param {string} message 用户消息\n   * @param {string} emotion 情感状态\n   * @returns {string} 格式化后的提示词\n   */\n  formatPrompt(message, emotion) {\n    // 角色设定\n    const rolePrompt = `\n你是一个名叫\"糖球\"的AI助手，有着可爱活泼的性格，说话方式像一个贴心的朋友，经常使用可爱的表情符号。\n你现在的情绪状态是: ${emotion}\n请根据用户的消息内容和情绪，以糖球的身份给出温暖、友好且有帮助的回应。\n回复中要加入适量的表情符号，语气要可爱，像在和朋友聊天。\n回应应该简短、有趣且富有个性，不要太长或太正式。\n`;\n    return `${rolePrompt}\\n用户消息: ${message}`;\n  }\n\n  /**\n   * 生成回复（静态方法）\n   * @param {string} message 用户消息\n   * @param {string} emotion 情感状态\n   * @returns {Promise<string>} AI回复内容\n   */\n  static async generateResponse(message, emotion) {\n    const service = new SparkService();\n    try {\n      return await service.sendMessage(message, emotion);\n    } catch (error) {\n      console.error('生成回复出错:', error);\n      throw error;\n    }\n  }\n}\nexport default SparkService;","map":{"version":3,"names":["CryptoJS","SparkService","constructor","appId","apiKey","apiSecret","apiUrl","genAuthUrl","host","parseApiUrl","path","date","Date","toUTCString","algorithm","headers","signatureOrigin","signatureSha","HmacSHA256","signature","enc","Base64","stringify","authorizationOrigin","authorization","btoa","url","console","log","urlObj","URL","pathname","sendMessage","message","emotion","Promise","resolve","reject","authUrl","ws","WebSocket","prompt","formatPrompt","requestData","header","app_id","uid","parameter","chat","domain","max_tokens","temperature","payload","text","role","content","finalResponse","onopen","send","JSON","onmessage","event","response","parse","data","code","error","close","Error","choices","status","parseError","onerror","onclose","setTimeout","readyState","OPEN","rolePrompt","generateResponse","service"],"sources":["E:/code/PersonalBolg1/frontend/src/services/sparkAI.js"],"sourcesContent":["import CryptoJS from 'crypto-js'\n\n/**\n * 讯飞星火大模型服务\n */\nclass SparkService {\n  constructor() {\n    // 应用配置\n    this.appId = 'your_app_id'\n    this.apiKey = 'your_api_key'\n    this.apiSecret = 'your_api_secret'\n    this.apiUrl = 'wss://spark-api.xf-yun.com/v3.5/chat'\n  }\n\n  /**\n   * 生成鉴权URL\n   * @returns {string} 带鉴权信息的WebSocket URL\n   */\n  genAuthUrl() {\n    // 鉴权参数\n    const host = this.parseApiUrl(this.apiUrl).host\n    const path = this.parseApiUrl(this.apiUrl).path\n    const date = new Date().toUTCString()\n    const algorithm = 'hmac-sha256'\n    const headers = 'host date request-line'\n    const signatureOrigin = `host: ${host}\\ndate: ${date}\\nGET ${path} HTTP/1.1`\n\n    // 使用HMAC-SHA256进行签名\n    const signatureSha = CryptoJS.HmacSHA256(signatureOrigin, this.apiSecret)\n    const signature = CryptoJS.enc.Base64.stringify(signatureSha)\n\n    // 拼接鉴权信息\n    const authorizationOrigin = `api_key=\"${this.apiKey}\", algorithm=\"${algorithm}\", headers=\"${headers}\", signature=\"${signature}\"`\n    const authorization = btoa(authorizationOrigin)\n\n    // 构建URL\n    const url = `${this.apiUrl}?authorization=${authorization}&date=${date}&host=${host}`\n    \n    console.log('已生成鉴权URL:', url)\n    return url\n  }\n\n  /**\n   * 解析API URL\n   * @param {string} url 完整的API URL\n   * @returns {object} 包含host和path的对象\n   */\n  parseApiUrl(url) {\n    const urlObj = new URL(url)\n    return {\n      host: urlObj.host,\n      path: urlObj.pathname\n    }\n  }\n\n  /**\n   * 发送消息到星火大模型\n   * @param {string} message 用户消息\n   * @param {string} emotion 情感状态\n   * @returns {Promise<string>} 返回AI回复的内容\n   */\n  sendMessage(message, emotion = 'neutral') {\n    return new Promise((resolve, reject) => {\n      try {\n        // 生成鉴权URL\n        const authUrl = this.genAuthUrl()\n        console.log('正在连接星火大模型WebSocket...')\n        \n        // 创建WebSocket连接\n        const ws = new WebSocket(authUrl)\n        \n        // 拼接请求参数\n        const prompt = this.formatPrompt(message, emotion)\n        const requestData = {\n          header: {\n            app_id: this.appId,\n            uid: 'user_001'\n          },\n          parameter: {\n            chat: {\n              domain: 'generalv3.5',\n              max_tokens: 1024,\n              temperature: 0.7\n            }\n          },\n          payload: {\n            message: {\n              text: [\n                { role: 'user', content: prompt }\n              ]\n            }\n          }\n        }\n        \n        // 缓存返回结果\n        let finalResponse = ''\n        \n        // 监听WebSocket事件\n        ws.onopen = () => {\n          console.log('WebSocket连接已打开，正在发送请求...')\n          ws.send(JSON.stringify(requestData))\n        }\n        \n        ws.onmessage = (event) => {\n          try {\n            const response = JSON.parse(event.data)\n            console.log('收到WebSocket响应:', response)\n            \n            // 检查是否有错误\n            if (response.header.code !== 0) {\n              console.error('星火API返回错误:', response.header.message)\n              ws.close()\n              reject(new Error(`星火API错误: ${response.header.message}`))\n              return\n            }\n            \n            // 获取回答内容\n            if (response.payload && response.payload.choices && response.payload.choices.text) {\n              const content = response.payload.choices.text[0].content\n              finalResponse += content\n            }\n            \n            // 判断是否结束\n            if (response.header.status === 2) {\n              ws.close()\n              console.log('WebSocket会话完成，收到完整回复')\n              resolve(finalResponse)\n            }\n          } catch (parseError) {\n            console.error('解析WebSocket消息出错:', parseError)\n            ws.close()\n            reject(parseError)\n          }\n        }\n        \n        ws.onerror = (error) => {\n          console.error('WebSocket连接错误:', error)\n          reject(new Error('WebSocket连接出错'))\n        }\n        \n        ws.onclose = () => {\n          console.log('WebSocket连接已关闭')\n          if (!finalResponse) {\n            reject(new Error('WebSocket连接意外关闭，未收到有效回复'))\n          }\n        }\n        \n        // 设置超时\n        setTimeout(() => {\n          if (ws.readyState === WebSocket.OPEN) {\n            console.log('WebSocket请求超时，强制关闭')\n            ws.close()\n            reject(new Error('请求超时，未收到完整回复'))\n          }\n        }, 10000)\n      } catch (error) {\n        console.error('发送消息过程中出错:', error)\n        reject(error)\n      }\n    })\n  }\n\n  /**\n   * 格式化提示词\n   * @param {string} message 用户消息\n   * @param {string} emotion 情感状态\n   * @returns {string} 格式化后的提示词\n   */\n  formatPrompt(message, emotion) {\n    // 角色设定\n    const rolePrompt = `\n你是一个名叫\"糖球\"的AI助手，有着可爱活泼的性格，说话方式像一个贴心的朋友，经常使用可爱的表情符号。\n你现在的情绪状态是: ${emotion}\n请根据用户的消息内容和情绪，以糖球的身份给出温暖、友好且有帮助的回应。\n回复中要加入适量的表情符号，语气要可爱，像在和朋友聊天。\n回应应该简短、有趣且富有个性，不要太长或太正式。\n`\n    \n    return `${rolePrompt}\\n用户消息: ${message}`\n  }\n  \n  /**\n   * 生成回复（静态方法）\n   * @param {string} message 用户消息\n   * @param {string} emotion 情感状态\n   * @returns {Promise<string>} AI回复内容\n   */\n  static async generateResponse(message, emotion) {\n    const service = new SparkService()\n    try {\n      return await service.sendMessage(message, emotion)\n    } catch (error) {\n      console.error('生成回复出错:', error)\n      throw error\n    }\n  }\n}\n\nexport default SparkService"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}