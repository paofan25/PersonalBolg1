{"ast":null,"code":"/**\n * 科大讯飞星火大模型API服务\n */\nclass SparkService {\n  constructor() {\n    // API配置（实际使用时应从环境变量获取）\n    this.appId = '8e347b2f';\n    this.apiKey = 'b6c51de4ab7fb4979878dc3e0b72efc1';\n    this.apiSecret = 'MWVlMGEzMjcxZGNhNjMwYmMwZDA0YTMw';\n    this.apiUrl = 'wss://spark-api.xf-yun.com/v3.5/chat';\n    this.ws = null;\n    this.currentResolve = null;\n    this.currentReject = null;\n    this.responseText = '';\n  }\n\n  /**\n   * 生成认证URL\n   * @returns {string} 认证URL\n   */\n  genAuthUrl() {\n    try {\n      const hostUrl = this.apiUrl.replace('wss://', '');\n      const date = new Date().toUTCString();\n      const algorithm = 'hmac-sha256';\n      const headers = 'host date request-line';\n      const signatureOrigin = `host: ${hostUrl}\\ndate: ${date}\\nGET /v3.5/chat HTTP/1.1`;\n\n      // 实际应用中应用crypto库计算签名\n      const hmacSha256 = content => {\n        // 此处简化，真实环境需使用加密库\n        console.log('计算HMAC-SHA256签名:', content);\n        return 'simulated_signature_value';\n      };\n\n      // 模拟签名过程\n      const signature = hmacSha256(signatureOrigin, this.apiSecret);\n\n      // 构建授权信息\n      const authUrl = `${this.apiUrl}?authorization=api_key=\"${this.apiKey}\",algorithm=\"${algorithm}\",headers=\"${headers}\",signature=\"${signature}\"&date=${encodeURI(date)}&host=${hostUrl}`;\n      console.log('生成认证URL成功');\n      return authUrl;\n    } catch (error) {\n      console.error('生成认证URL失败:', error);\n      throw new Error('生成认证URL失败');\n    }\n  }\n\n  /**\n   * 解析API URL\n   * @returns {string} 解析后的URL\n   */\n  parseApiUrl() {\n    try {\n      // 实际应用中应根据讯飞文档构建正确的URL\n      return this.apiUrl;\n    } catch (error) {\n      console.error('解析API URL失败:', error);\n      throw new Error('解析API URL失败');\n    }\n  }\n\n  /**\n   * 发送消息到星火API\n   * @param {string} message 用户消息\n   * @returns {Promise<string>} 星火模型响应\n   */\n  sendMessage(message) {\n    return new Promise((resolve, reject) => {\n      try {\n        console.log('准备发送消息到星火API:', message);\n\n        // 设置当前Promise的解析和拒绝函数\n        this.currentResolve = resolve;\n        this.currentReject = reject;\n        this.responseText = '';\n\n        // 创建WebSocket连接\n        const url = this.parseApiUrl();\n        this.ws = new WebSocket(url);\n        this.ws.onopen = () => {\n          console.log('WebSocket连接已打开');\n\n          // 构建请求数据\n          const requestData = {\n            header: {\n              app_id: this.appId,\n              uid: 'user_' + Math.random().toString(36).substr(2, 9)\n            },\n            parameter: {\n              chat: {\n                domain: 'generalv3.5',\n                temperature: 0.7,\n                max_tokens: 1024\n              }\n            },\n            payload: {\n              message: {\n                text: [{\n                  role: 'user',\n                  content: message\n                }]\n              }\n            }\n          };\n          console.log('发送请求数据:', JSON.stringify(requestData));\n          this.ws.send(JSON.stringify(requestData));\n        };\n        this.ws.onmessage = event => {\n          try {\n            const response = JSON.parse(event.data);\n            console.log('收到响应:', response);\n\n            // 解析响应数据\n            if (response.payload && response.payload.choices && response.payload.choices.text) {\n              const content = response.payload.choices.text[0].content;\n              this.responseText += content;\n            }\n\n            // 检查是否是最后一条消息\n            if (response.header && response.header.status === 2) {\n              console.log('接收完成, 完整响应:', this.responseText);\n              this.ws.close();\n              this.currentResolve(this.responseText);\n            }\n          } catch (error) {\n            console.error('处理响应数据时出错:', error);\n          }\n        };\n        this.ws.onerror = error => {\n          console.error('WebSocket错误:', error);\n          this.currentReject(new Error('WebSocket连接错误'));\n          this.ws.close();\n        };\n        this.ws.onclose = () => {\n          console.log('WebSocket连接已关闭');\n          if (this.responseText && this.currentResolve) {\n            this.currentResolve(this.responseText);\n          } else if (this.currentReject) {\n            this.currentReject(new Error('WebSocket连接已关闭，未能获取完整响应'));\n          }\n        };\n      } catch (error) {\n        console.error('发送消息时出错:', error);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * 格式化用户提示内容\n   * @param {string} content 用户消息\n   * @param {string} emotion 情绪状态\n   * @returns {string} 格式化后的提示内容\n   */\n  formatPrompt(content, emotion) {\n    // 根据不同情绪构建不同的提示\n    let emotionContext = '';\n    switch (emotion) {\n      case 'happy':\n        emotionContext = '用户现在很开心，保持愉快的交流氛围。';\n        break;\n      case 'sad':\n        emotionContext = '用户现在有些难过，提供安慰和鼓励。';\n        break;\n      case 'angry':\n        emotionContext = '用户现在情绪有些激动，保持冷静和理解。';\n        break;\n      case 'excited':\n        emotionContext = '用户现在很兴奋，以积极热情的方式回应。';\n        break;\n      default:\n        emotionContext = '保持自然友好的交流方式。';\n    }\n    const prompt = `\n你是一个名为\"糖球\"的可爱助手，来自甜梦星球。你的性格活泼、温暖、善解人意。请用简短自然的语气回答，像朋友一样交流，使用萌系语言风格，偶尔使用可爱的表情符号。注意事项：\n1. 回复简短友好，不超过3句话\n2. 使用生动活泼的语言，表达亲切感\n3. 不要过度使用礼貌用语，保持对话的自然感\n4. 适当加入表情符号或拟声词\n5. ${emotionContext}\n\n用户消息: ${content}\n糖球的回复:\n`;\n    return prompt;\n  }\n\n  /**\n   * 生成回复\n   * @param {string} content 用户消息\n   * @param {string} emotion 情绪状态\n   * @returns {Promise<string>} 生成的回复\n   */\n  async generateResponse(content, emotion) {\n    try {\n      console.log('准备生成回复, 情绪:', emotion);\n      const prompt = this.formatPrompt(content, emotion);\n      console.log('格式化后的提示:', prompt);\n\n      // 发送到星火API\n      const response = await this.sendMessage(prompt);\n      console.log('星火API返回原始响应:', response);\n\n      // 处理响应\n      return response || '啊哦，我好像有点迷糊了，能再说一遍吗？ 🤔';\n    } catch (error) {\n      console.error('生成回复时出错:', error);\n      return '抱歉，我现在有点小问题，一会儿再聊吧~ 🙈';\n    }\n  }\n}\n\n// 导出单例\nexport default new SparkService();","map":{"version":3,"names":["SparkService","constructor","appId","apiKey","apiSecret","apiUrl","ws","currentResolve","currentReject","responseText","genAuthUrl","hostUrl","replace","date","Date","toUTCString","algorithm","headers","signatureOrigin","hmacSha256","content","console","log","signature","authUrl","encodeURI","error","Error","parseApiUrl","sendMessage","message","Promise","resolve","reject","url","WebSocket","onopen","requestData","header","app_id","uid","Math","random","toString","substr","parameter","chat","domain","temperature","max_tokens","payload","text","role","JSON","stringify","send","onmessage","event","response","parse","data","choices","status","close","onerror","onclose","formatPrompt","emotion","emotionContext","prompt","generateResponse"],"sources":["E:/code/PersonalBolg1/frontend/src/services/sparkAI.js"],"sourcesContent":["/**\n * 科大讯飞星火大模型API服务\n */\nclass SparkService {\n  constructor() {\n    // API配置（实际使用时应从环境变量获取）\n    this.appId = '8e347b2f'\n    this.apiKey = 'b6c51de4ab7fb4979878dc3e0b72efc1'\n    this.apiSecret = 'MWVlMGEzMjcxZGNhNjMwYmMwZDA0YTMw'\n    this.apiUrl = 'wss://spark-api.xf-yun.com/v3.5/chat'\n    \n    this.ws = null\n    this.currentResolve = null\n    this.currentReject = null\n    this.responseText = ''\n  }\n\n  /**\n   * 生成认证URL\n   * @returns {string} 认证URL\n   */\n  genAuthUrl() {\n    try {\n      const hostUrl = this.apiUrl.replace('wss://', '')\n      const date = new Date().toUTCString()\n      const algorithm = 'hmac-sha256'\n      const headers = 'host date request-line'\n      const signatureOrigin = `host: ${hostUrl}\\ndate: ${date}\\nGET /v3.5/chat HTTP/1.1`\n      \n      // 实际应用中应用crypto库计算签名\n      const hmacSha256 = content => {\n        // 此处简化，真实环境需使用加密库\n        console.log('计算HMAC-SHA256签名:', content)\n        return 'simulated_signature_value'\n      }\n      \n      // 模拟签名过程\n      const signature = hmacSha256(signatureOrigin, this.apiSecret)\n      \n      // 构建授权信息\n      const authUrl = `${this.apiUrl}?authorization=api_key=\"${this.apiKey}\",algorithm=\"${algorithm}\",headers=\"${headers}\",signature=\"${signature}\"&date=${encodeURI(date)}&host=${hostUrl}`\n      \n      console.log('生成认证URL成功')\n      return authUrl\n    } catch (error) {\n      console.error('生成认证URL失败:', error)\n      throw new Error('生成认证URL失败')\n    }\n  }\n\n  /**\n   * 解析API URL\n   * @returns {string} 解析后的URL\n   */\n  parseApiUrl() {\n    try {\n      // 实际应用中应根据讯飞文档构建正确的URL\n      return this.apiUrl\n    } catch (error) {\n      console.error('解析API URL失败:', error)\n      throw new Error('解析API URL失败')\n    }\n  }\n\n  /**\n   * 发送消息到星火API\n   * @param {string} message 用户消息\n   * @returns {Promise<string>} 星火模型响应\n   */\n  sendMessage(message) {\n    return new Promise((resolve, reject) => {\n      try {\n        console.log('准备发送消息到星火API:', message)\n        \n        // 设置当前Promise的解析和拒绝函数\n        this.currentResolve = resolve\n        this.currentReject = reject\n        this.responseText = ''\n        \n        // 创建WebSocket连接\n        const url = this.parseApiUrl()\n        this.ws = new WebSocket(url)\n        \n        this.ws.onopen = () => {\n          console.log('WebSocket连接已打开')\n          \n          // 构建请求数据\n          const requestData = {\n            header: {\n              app_id: this.appId,\n              uid: 'user_' + Math.random().toString(36).substr(2, 9)\n            },\n            parameter: {\n              chat: {\n                domain: 'generalv3.5',\n                temperature: 0.7,\n                max_tokens: 1024\n              }\n            },\n            payload: {\n              message: {\n                text: [\n                  {\n                    role: 'user',\n                    content: message\n                  }\n                ]\n              }\n            }\n          }\n          \n          console.log('发送请求数据:', JSON.stringify(requestData))\n          this.ws.send(JSON.stringify(requestData))\n        }\n        \n        this.ws.onmessage = (event) => {\n          try {\n            const response = JSON.parse(event.data)\n            console.log('收到响应:', response)\n            \n            // 解析响应数据\n            if (response.payload && response.payload.choices && response.payload.choices.text) {\n              const content = response.payload.choices.text[0].content\n              this.responseText += content\n            }\n            \n            // 检查是否是最后一条消息\n            if (response.header && response.header.status === 2) {\n              console.log('接收完成, 完整响应:', this.responseText)\n              this.ws.close()\n              this.currentResolve(this.responseText)\n            }\n          } catch (error) {\n            console.error('处理响应数据时出错:', error)\n          }\n        }\n        \n        this.ws.onerror = (error) => {\n          console.error('WebSocket错误:', error)\n          this.currentReject(new Error('WebSocket连接错误'))\n          this.ws.close()\n        }\n        \n        this.ws.onclose = () => {\n          console.log('WebSocket连接已关闭')\n          if (this.responseText && this.currentResolve) {\n            this.currentResolve(this.responseText)\n          } else if (this.currentReject) {\n            this.currentReject(new Error('WebSocket连接已关闭，未能获取完整响应'))\n          }\n        }\n      } catch (error) {\n        console.error('发送消息时出错:', error)\n        reject(error)\n      }\n    })\n  }\n\n  /**\n   * 格式化用户提示内容\n   * @param {string} content 用户消息\n   * @param {string} emotion 情绪状态\n   * @returns {string} 格式化后的提示内容\n   */\n  formatPrompt(content, emotion) {\n    // 根据不同情绪构建不同的提示\n    let emotionContext = ''\n    switch (emotion) {\n      case 'happy':\n        emotionContext = '用户现在很开心，保持愉快的交流氛围。'\n        break\n      case 'sad':\n        emotionContext = '用户现在有些难过，提供安慰和鼓励。'\n        break\n      case 'angry':\n        emotionContext = '用户现在情绪有些激动，保持冷静和理解。'\n        break\n      case 'excited':\n        emotionContext = '用户现在很兴奋，以积极热情的方式回应。'\n        break\n      default:\n        emotionContext = '保持自然友好的交流方式。'\n    }\n    \n    const prompt = `\n你是一个名为\"糖球\"的可爱助手，来自甜梦星球。你的性格活泼、温暖、善解人意。请用简短自然的语气回答，像朋友一样交流，使用萌系语言风格，偶尔使用可爱的表情符号。注意事项：\n1. 回复简短友好，不超过3句话\n2. 使用生动活泼的语言，表达亲切感\n3. 不要过度使用礼貌用语，保持对话的自然感\n4. 适当加入表情符号或拟声词\n5. ${emotionContext}\n\n用户消息: ${content}\n糖球的回复:\n`\n    \n    return prompt\n  }\n\n  /**\n   * 生成回复\n   * @param {string} content 用户消息\n   * @param {string} emotion 情绪状态\n   * @returns {Promise<string>} 生成的回复\n   */\n  async generateResponse(content, emotion) {\n    try {\n      console.log('准备生成回复, 情绪:', emotion)\n      const prompt = this.formatPrompt(content, emotion)\n      console.log('格式化后的提示:', prompt)\n      \n      // 发送到星火API\n      const response = await this.sendMessage(prompt)\n      console.log('星火API返回原始响应:', response)\n      \n      // 处理响应\n      return response || '啊哦，我好像有点迷糊了，能再说一遍吗？ 🤔'\n    } catch (error) {\n      console.error('生成回复时出错:', error)\n      return '抱歉，我现在有点小问题，一会儿再聊吧~ 🙈'\n    }\n  }\n}\n\n// 导出单例\nexport default new SparkService()"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}