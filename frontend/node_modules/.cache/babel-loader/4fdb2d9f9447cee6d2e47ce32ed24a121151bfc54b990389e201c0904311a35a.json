{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport CryptoJS from 'crypto-js';\n\n/**\n * 讯飞星火大模型服务接口\n */\nclass SparkService {\n  constructor() {\n    // API配置\n    this.appId = '8fa9d3e0';\n    this.apiKey = 'cda47a94c53d0dba25c59f5b86cc9766';\n    this.apiSecret = '81558c86df2372ef5d5c77ff1fed6f01';\n    this.apiUrl = 'wss://spark-api.xf-yun.com/v2.1/chat';\n\n    // WebSocket连接\n    this.ws = null;\n    this.messageQueue = [];\n    this.resolve = null;\n    this.reject = null;\n  }\n\n  /**\n   * 生成认证URL\n   * @returns {string} 带有认证信息的URL\n   */\n  genAuthUrl() {\n    const host = 'spark-api.xf-yun.com/v2.1/chat';\n    const date = new Date().toGMTString();\n    const algorithm = 'hmac-sha256';\n    const headers = 'host date request-line';\n    const requestLine = 'GET /v2.1/chat HTTP/1.1';\n    const signature_origin = `host: ${host}\\ndate: ${date}\\n${requestLine}`;\n\n    // 使用apiSecret生成签名\n    const signature_sha = CryptoJS.HmacSHA256(signature_origin, this.apiSecret);\n    const signature = CryptoJS.enc.Base64.stringify(signature_sha);\n\n    // 构建认证字符串\n    const authorization_origin = `api_key=\"${this.apiKey}\", algorithm=\"${algorithm}\", headers=\"${headers}\", signature=\"${signature}\"`;\n\n    // Base64编码\n    const authorization = CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(authorization_origin));\n\n    // 构建URL\n    const url = `${this.apiUrl}?authorization=${authorization}&date=${encodeURI(date)}&host=${host}`;\n    return url;\n  }\n\n  /**\n   * 解析API URL并返回\n   * @returns {string} API URL\n   */\n  parseApiUrl() {\n    try {\n      // 生成带认证信息的URL\n      const url = this.genAuthUrl();\n      console.log('API URL生成成功');\n      return url;\n    } catch (error) {\n      console.error('API URL解析失败:', error);\n      throw new Error('无法生成API URL');\n    }\n  }\n\n  /**\n   * 发送消息到星火大模型\n   * @param {string} message 用户消息\n   * @returns {Promise<string>} 模型回复\n   */\n  sendMessage(message) {\n    return new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n      try {\n        const url = this.parseApiUrl();\n\n        // 创建WebSocket连接\n        this.ws = new WebSocket(url);\n\n        // 设置事件处理器\n        this.ws.onopen = () => {\n          console.log('WebSocket连接已建立');\n          // 构建请求数据\n          const requestData = this.formatPrompt(message);\n          console.log('发送请求:', JSON.stringify(requestData));\n\n          // 发送数据\n          this.ws.send(JSON.stringify(requestData));\n        };\n\n        // 接收消息\n        this.ws.onmessage = event => {\n          try {\n            const response = JSON.parse(event.data);\n            console.log('收到回复:', response);\n\n            // 处理回复\n            if (response.header.code !== 0) {\n              console.error('API错误:', response.header.message);\n              this.ws.close();\n              reject(new Error(`API错误: ${response.header.code} ${response.header.message}`));\n              return;\n            }\n\n            // 收集回复文本\n            if (response.payload.choices.text) {\n              const text = response.payload.choices.text[0].content;\n              this.messageQueue.push(text);\n            }\n\n            // 判断是否结束\n            if (response.header.status === 2) {\n              // 合并消息并返回\n              const fullMessage = this.messageQueue.join('');\n              this.ws.close();\n              resolve(fullMessage);\n            }\n          } catch (error) {\n            console.error('解析响应失败:', error);\n            this.ws.close();\n            reject(error);\n          }\n        };\n\n        // 错误处理\n        this.ws.onerror = error => {\n          console.error('WebSocket错误:', error);\n          reject(error);\n        };\n\n        // 连接关闭\n        this.ws.onclose = () => {\n          console.log('WebSocket连接已关闭');\n        };\n      } catch (error) {\n        console.error('发送消息失败:', error);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * 格式化提示词\n   * @param {string} message 用户消息\n   * @returns {Object} 格式化的请求数据\n   */\n  formatPrompt(message) {\n    return {\n      header: {\n        app_id: this.appId\n      },\n      parameter: {\n        chat: {\n          domain: 'general',\n          temperature: 0.7,\n          max_tokens: 1024\n        }\n      },\n      payload: {\n        message: {\n          text: [{\n            role: 'user',\n            content: message\n          }]\n        }\n      }\n    };\n  }\n\n  /**\n   * 生成回复（静态方法）\n   * @param {string} message 用户消息\n   * @param {string} emotion 情绪状态\n   * @returns {Promise<string>} 生成的回复\n   */\n  static async generateResponse(message, emotion) {\n    try {\n      const sparkService = new SparkService();\n\n      // 根据情绪调整提示词\n      let prompt = message;\n      switch (emotion) {\n        case 'happy':\n          prompt = `用户心情很好，请用开心活泼的语气回答: ${message}`;\n          break;\n        case 'sad':\n          prompt = `用户心情不好，请用温柔安慰的语气回答: ${message}`;\n          break;\n        case 'excited':\n          prompt = `用户很兴奋，请用热情积极的语气回答: ${message}`;\n          break;\n        default:\n          prompt = `请回答用户的问题: ${message}`;\n      }\n\n      // 发送到API\n      const response = await sparkService.sendMessage(prompt);\n      return response;\n    } catch (error) {\n      console.error('生成回复失败:', error);\n      throw error;\n    }\n  }\n}\nexport default SparkService;","map":{"version":3,"names":["CryptoJS","SparkService","constructor","appId","apiKey","apiSecret","apiUrl","ws","messageQueue","resolve","reject","genAuthUrl","host","date","Date","toGMTString","algorithm","headers","requestLine","signature_origin","signature_sha","HmacSHA256","signature","enc","Base64","stringify","authorization_origin","authorization","Utf8","parse","url","encodeURI","parseApiUrl","console","log","error","Error","sendMessage","message","Promise","WebSocket","onopen","requestData","formatPrompt","JSON","send","onmessage","event","response","data","header","code","close","payload","choices","text","content","push","status","fullMessage","join","onerror","onclose","app_id","parameter","chat","domain","temperature","max_tokens","role","generateResponse","emotion","sparkService","prompt"],"sources":["E:/code/PersonalBolg1/frontend/src/services/sparkAI.js"],"sourcesContent":["import CryptoJS from 'crypto-js'\n\n/**\n * 讯飞星火大模型服务接口\n */\nclass SparkService {\n  constructor() {\n    // API配置\n    this.appId = '8fa9d3e0'\n    this.apiKey = 'cda47a94c53d0dba25c59f5b86cc9766'\n    this.apiSecret = '81558c86df2372ef5d5c77ff1fed6f01'\n    this.apiUrl = 'wss://spark-api.xf-yun.com/v2.1/chat'\n    \n    // WebSocket连接\n    this.ws = null\n    this.messageQueue = []\n    this.resolve = null\n    this.reject = null\n  }\n\n  /**\n   * 生成认证URL\n   * @returns {string} 带有认证信息的URL\n   */\n  genAuthUrl() {\n    const host = 'spark-api.xf-yun.com/v2.1/chat'\n    const date = new Date().toGMTString()\n    const algorithm = 'hmac-sha256'\n    const headers = 'host date request-line'\n    const requestLine = 'GET /v2.1/chat HTTP/1.1'\n    const signature_origin = `host: ${host}\\ndate: ${date}\\n${requestLine}`\n    \n    // 使用apiSecret生成签名\n    const signature_sha = CryptoJS.HmacSHA256(signature_origin, this.apiSecret)\n    const signature = CryptoJS.enc.Base64.stringify(signature_sha)\n    \n    // 构建认证字符串\n    const authorization_origin = `api_key=\"${this.apiKey}\", algorithm=\"${algorithm}\", headers=\"${headers}\", signature=\"${signature}\"`\n    \n    // Base64编码\n    const authorization = CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(authorization_origin))\n    \n    // 构建URL\n    const url = `${this.apiUrl}?authorization=${authorization}&date=${encodeURI(date)}&host=${host}`\n    \n    return url\n  }\n\n  /**\n   * 解析API URL并返回\n   * @returns {string} API URL\n   */\n  parseApiUrl() {\n    try {\n      // 生成带认证信息的URL\n      const url = this.genAuthUrl()\n      console.log('API URL生成成功')\n      return url\n    } catch (error) {\n      console.error('API URL解析失败:', error)\n      throw new Error('无法生成API URL')\n    }\n  }\n\n  /**\n   * 发送消息到星火大模型\n   * @param {string} message 用户消息\n   * @returns {Promise<string>} 模型回复\n   */\n  sendMessage(message) {\n    return new Promise((resolve, reject) => {\n      this.resolve = resolve\n      this.reject = reject\n      \n      try {\n        const url = this.parseApiUrl()\n        \n        // 创建WebSocket连接\n        this.ws = new WebSocket(url)\n        \n        // 设置事件处理器\n        this.ws.onopen = () => {\n          console.log('WebSocket连接已建立')\n          // 构建请求数据\n          const requestData = this.formatPrompt(message)\n          console.log('发送请求:', JSON.stringify(requestData))\n          \n          // 发送数据\n          this.ws.send(JSON.stringify(requestData))\n        }\n        \n        // 接收消息\n        this.ws.onmessage = (event) => {\n          try {\n            const response = JSON.parse(event.data)\n            console.log('收到回复:', response)\n            \n            // 处理回复\n            if (response.header.code !== 0) {\n              console.error('API错误:', response.header.message)\n              this.ws.close()\n              reject(new Error(`API错误: ${response.header.code} ${response.header.message}`))\n              return\n            }\n            \n            // 收集回复文本\n            if (response.payload.choices.text) {\n              const text = response.payload.choices.text[0].content\n              this.messageQueue.push(text)\n            }\n            \n            // 判断是否结束\n            if (response.header.status === 2) {\n              // 合并消息并返回\n              const fullMessage = this.messageQueue.join('')\n              this.ws.close()\n              resolve(fullMessage)\n            }\n          } catch (error) {\n            console.error('解析响应失败:', error)\n            this.ws.close()\n            reject(error)\n          }\n        }\n        \n        // 错误处理\n        this.ws.onerror = (error) => {\n          console.error('WebSocket错误:', error)\n          reject(error)\n        }\n        \n        // 连接关闭\n        this.ws.onclose = () => {\n          console.log('WebSocket连接已关闭')\n        }\n      } catch (error) {\n        console.error('发送消息失败:', error)\n        reject(error)\n      }\n    })\n  }\n\n  /**\n   * 格式化提示词\n   * @param {string} message 用户消息\n   * @returns {Object} 格式化的请求数据\n   */\n  formatPrompt(message) {\n    return {\n      header: {\n        app_id: this.appId\n      },\n      parameter: {\n        chat: {\n          domain: 'general',\n          temperature: 0.7,\n          max_tokens: 1024\n        }\n      },\n      payload: {\n        message: {\n          text: [\n            {\n              role: 'user',\n              content: message\n            }\n          ]\n        }\n      }\n    }\n  }\n\n  /**\n   * 生成回复（静态方法）\n   * @param {string} message 用户消息\n   * @param {string} emotion 情绪状态\n   * @returns {Promise<string>} 生成的回复\n   */\n  static async generateResponse(message, emotion) {\n    try {\n      const sparkService = new SparkService()\n      \n      // 根据情绪调整提示词\n      let prompt = message\n      switch (emotion) {\n        case 'happy':\n          prompt = `用户心情很好，请用开心活泼的语气回答: ${message}`\n          break\n        case 'sad':\n          prompt = `用户心情不好，请用温柔安慰的语气回答: ${message}`\n          break\n        case 'excited':\n          prompt = `用户很兴奋，请用热情积极的语气回答: ${message}`\n          break\n        default:\n          prompt = `请回答用户的问题: ${message}`\n      }\n      \n      // 发送到API\n      const response = await sparkService.sendMessage(prompt)\n      return response\n    } catch (error) {\n      console.error('生成回复失败:', error)\n      throw error\n    }\n  }\n}\n\nexport default SparkService"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}