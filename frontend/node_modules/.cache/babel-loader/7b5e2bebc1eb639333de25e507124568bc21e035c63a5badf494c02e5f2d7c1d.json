{"ast":null,"code":"import \"core-js/modules/web.dom-exception.stack.js\";\nimport CryptoJS from 'crypto-js';\n\n/**\n * 讯飞星火大模型服务类\n */\nclass SparkService {\n  constructor() {\n    // API配置\n    this.appId = '7d19305e';\n    this.apiKey = '3ee8bcdf8cf01de88be6275b3a136e2d';\n    this.apiSecret = 'ZjYzMTQ2MTRiOTYwMTAxYTZhMzRkNTE0';\n    this.apiUrl = 'wss://spark-api.xf-yun.com/v2.1/chat';\n  }\n\n  /**\n   * 生成认证URL\n   * @returns {string} 认证URL\n   */\n  genAuthUrl() {\n    const host = 'spark-api.xf-yun.com';\n    const path = '/v2.1/chat';\n    const date = new Date().toUTCString();\n    const algorithm = 'hmac-sha256';\n    const headers = 'host date request-line';\n    const signatureOrigin = `host: ${host}\\ndate: ${date}\\nGET ${path} HTTP/1.1`;\n    const signatureSha = CryptoJS.HmacSHA256(signatureOrigin, this.apiSecret);\n    const signature = CryptoJS.enc.Base64.stringify(signatureSha);\n    const authorizationOrigin = `api_key=\"${this.apiKey}\", algorithm=\"${algorithm}\", headers=\"${headers}\", signature=\"${signature}\"`;\n    const authorization = btoa(authorizationOrigin);\n\n    // 拼接url\n    return `${this.apiUrl}?authorization=${authorization}&date=${encodeURI(date)}&host=${host}`;\n  }\n\n  /**\n   * 解析API URL\n   * @returns {string} 解析后的URL\n   */\n  parseApiUrl() {\n    try {\n      const url = this.genAuthUrl();\n      console.log('API URL生成成功:', url);\n      return url;\n    } catch (error) {\n      console.error('解析API URL失败:', error);\n      throw new Error('无法生成认证URL');\n    }\n  }\n\n  /**\n   * 发送消息到星火大模型\n   * @param {string} message 用户消息\n   * @returns {Promise<string>} 响应内容\n   */\n  async sendMessage(message) {\n    return new Promise((resolve, reject) => {\n      try {\n        const url = this.parseApiUrl();\n        const ws = new WebSocket(url);\n        let finalResponse = '';\n\n        // 连接建立\n        ws.onopen = () => {\n          console.log('WebSocket连接建立成功');\n          // 发送消息\n          const prompt = this.formatPrompt(message);\n          ws.send(JSON.stringify(prompt));\n        };\n\n        // 接收消息\n        ws.onmessage = event => {\n          try {\n            const response = JSON.parse(event.data);\n            console.log('收到响应:', response);\n\n            // 处理响应\n            if (response.header.code !== 0) {\n              console.error('API请求错误:', response.header.message);\n              ws.close();\n              reject(new Error(`API请求错误: ${response.header.code} ${response.header.message}`));\n              return;\n            }\n\n            // 获取回复内容\n            if (response.payload && response.payload.choices && response.payload.choices.text) {\n              const content = response.payload.choices.text[0].content;\n              finalResponse += content;\n\n              // 如果响应已完成，关闭连接\n              if (response.header.status === 2) {\n                ws.close();\n                resolve(finalResponse);\n              }\n            }\n          } catch (error) {\n            console.error('解析响应失败:', error);\n            ws.close();\n            reject(error);\n          }\n        };\n\n        // 连接关闭\n        ws.onclose = () => {\n          console.log('WebSocket连接已关闭');\n          if (finalResponse) {\n            resolve(finalResponse);\n          }\n        };\n\n        // 连接错误\n        ws.onerror = error => {\n          console.error('WebSocket错误:', error);\n          reject(error);\n        };\n\n        // 超时处理\n        setTimeout(() => {\n          if (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN) {\n            ws.close();\n            reject(new Error('请求超时'));\n          }\n        }, 30000);\n      } catch (error) {\n        console.error('发送消息失败:', error);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * 格式化用户提示\n   * @param {string} message 用户消息\n   * @returns {Object} 格式化的提示\n   */\n  formatPrompt(message) {\n    return {\n      header: {\n        app_id: this.appId\n      },\n      parameter: {\n        chat: {\n          domain: 'general',\n          temperature: 0.5,\n          max_tokens: 1024\n        }\n      },\n      payload: {\n        message: {\n          text: [{\n            role: 'user',\n            content: message\n          }]\n        }\n      }\n    };\n  }\n\n  /**\n   * 根据情绪生成回复\n   * @param {string} message 用户消息\n   * @param {string} emotion 情绪状态\n   * @returns {Promise<string>} 生成的回复\n   */\n  static async generateResponse(message, emotion) {\n    try {\n      const service = new SparkService();\n\n      // 根据情绪调整提示语\n      let prompt = message;\n      switch (emotion) {\n        case 'happy':\n          prompt = `用户看起来很开心。他说:\"${message}\" 我应该以开心温暖的语气回应。`;\n          break;\n        case 'sad':\n          prompt = `用户看起来有些伤心。他说:\"${message}\" 我应该以安慰关心的语气回应。`;\n          break;\n        case 'excited':\n          prompt = `用户看起来很兴奋。他说:\"${message}\" 我应该以热情积极的语气回应。`;\n          break;\n        case 'angry':\n          prompt = `用户看起来有些生气。他说:\"${message}\" 我应该以冷静理解的语气回应。`;\n          break;\n        default:\n          prompt = `用户说:\"${message}\" 请以友好自然的语气回应。`;\n      }\n\n      // 添加角色设定\n      prompt = `你是一个叫糖球的可爱助手，有着甜甜的性格和温暖的对话风格。\n你应该像个知心朋友一样回应用户，使用可爱的语气，偶尔加入一些轻松的表情。\n不需要过于正式，而是保持亲切友好的态度。注意你的回答要简洁，不要太长。\n${prompt}`;\n\n      // 发送到API并获取回复\n      return await service.sendMessage(prompt);\n    } catch (error) {\n      console.error('生成回复失败:', error);\n      throw error;\n    }\n  }\n}\nexport default SparkService;","map":{"version":3,"names":["CryptoJS","SparkService","constructor","appId","apiKey","apiSecret","apiUrl","genAuthUrl","host","path","date","Date","toUTCString","algorithm","headers","signatureOrigin","signatureSha","HmacSHA256","signature","enc","Base64","stringify","authorizationOrigin","authorization","btoa","encodeURI","parseApiUrl","url","console","log","error","Error","sendMessage","message","Promise","resolve","reject","ws","WebSocket","finalResponse","onopen","prompt","formatPrompt","send","JSON","onmessage","event","response","parse","data","header","code","close","payload","choices","text","content","status","onclose","onerror","setTimeout","readyState","CONNECTING","OPEN","app_id","parameter","chat","domain","temperature","max_tokens","role","generateResponse","emotion","service"],"sources":["E:/code/PersonalBolg1/frontend/src/services/sparkAI.js"],"sourcesContent":["import CryptoJS from 'crypto-js'\n\n/**\n * 讯飞星火大模型服务类\n */\nclass SparkService {\n  constructor() {\n    // API配置\n    this.appId = '7d19305e'\n    this.apiKey = '3ee8bcdf8cf01de88be6275b3a136e2d'\n    this.apiSecret = 'ZjYzMTQ2MTRiOTYwMTAxYTZhMzRkNTE0'\n    this.apiUrl = 'wss://spark-api.xf-yun.com/v2.1/chat'\n  }\n\n  /**\n   * 生成认证URL\n   * @returns {string} 认证URL\n   */\n  genAuthUrl() {\n    const host = 'spark-api.xf-yun.com'\n    const path = '/v2.1/chat'\n    const date = new Date().toUTCString()\n    const algorithm = 'hmac-sha256'\n    const headers = 'host date request-line'\n    const signatureOrigin = `host: ${host}\\ndate: ${date}\\nGET ${path} HTTP/1.1`\n    \n    const signatureSha = CryptoJS.HmacSHA256(signatureOrigin, this.apiSecret)\n    const signature = CryptoJS.enc.Base64.stringify(signatureSha)\n    \n    const authorizationOrigin = `api_key=\"${this.apiKey}\", algorithm=\"${algorithm}\", headers=\"${headers}\", signature=\"${signature}\"`\n    const authorization = btoa(authorizationOrigin)\n    \n    // 拼接url\n    return `${this.apiUrl}?authorization=${authorization}&date=${encodeURI(date)}&host=${host}`\n  }\n\n  /**\n   * 解析API URL\n   * @returns {string} 解析后的URL\n   */\n  parseApiUrl() {\n    try {\n      const url = this.genAuthUrl()\n      console.log('API URL生成成功:', url)\n      return url\n    } catch (error) {\n      console.error('解析API URL失败:', error)\n      throw new Error('无法生成认证URL')\n    }\n  }\n\n  /**\n   * 发送消息到星火大模型\n   * @param {string} message 用户消息\n   * @returns {Promise<string>} 响应内容\n   */\n  async sendMessage(message) {\n    return new Promise((resolve, reject) => {\n      try {\n        const url = this.parseApiUrl()\n        const ws = new WebSocket(url)\n        let finalResponse = ''\n        \n        // 连接建立\n        ws.onopen = () => {\n          console.log('WebSocket连接建立成功')\n          // 发送消息\n          const prompt = this.formatPrompt(message)\n          ws.send(JSON.stringify(prompt))\n        }\n        \n        // 接收消息\n        ws.onmessage = (event) => {\n          try {\n            const response = JSON.parse(event.data)\n            console.log('收到响应:', response)\n            \n            // 处理响应\n            if (response.header.code !== 0) {\n              console.error('API请求错误:', response.header.message)\n              ws.close()\n              reject(new Error(`API请求错误: ${response.header.code} ${response.header.message}`))\n              return\n            }\n            \n            // 获取回复内容\n            if (response.payload && response.payload.choices && response.payload.choices.text) {\n              const content = response.payload.choices.text[0].content\n              finalResponse += content\n              \n              // 如果响应已完成，关闭连接\n              if (response.header.status === 2) {\n                ws.close()\n                resolve(finalResponse)\n              }\n            }\n          } catch (error) {\n            console.error('解析响应失败:', error)\n            ws.close()\n            reject(error)\n          }\n        }\n        \n        // 连接关闭\n        ws.onclose = () => {\n          console.log('WebSocket连接已关闭')\n          if (finalResponse) {\n            resolve(finalResponse)\n          }\n        }\n        \n        // 连接错误\n        ws.onerror = (error) => {\n          console.error('WebSocket错误:', error)\n          reject(error)\n        }\n        \n        // 超时处理\n        setTimeout(() => {\n          if (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN) {\n            ws.close()\n            reject(new Error('请求超时'))\n          }\n        }, 30000)\n      } catch (error) {\n        console.error('发送消息失败:', error)\n        reject(error)\n      }\n    })\n  }\n\n  /**\n   * 格式化用户提示\n   * @param {string} message 用户消息\n   * @returns {Object} 格式化的提示\n   */\n  formatPrompt(message) {\n    return {\n      header: {\n        app_id: this.appId\n      },\n      parameter: {\n        chat: {\n          domain: 'general',\n          temperature: 0.5,\n          max_tokens: 1024\n        }\n      },\n      payload: {\n        message: {\n          text: [\n            {\n              role: 'user',\n              content: message\n            }\n          ]\n        }\n      }\n    }\n  }\n\n  /**\n   * 根据情绪生成回复\n   * @param {string} message 用户消息\n   * @param {string} emotion 情绪状态\n   * @returns {Promise<string>} 生成的回复\n   */\n  static async generateResponse(message, emotion) {\n    try {\n      const service = new SparkService()\n      \n      // 根据情绪调整提示语\n      let prompt = message\n      \n      switch (emotion) {\n        case 'happy':\n          prompt = `用户看起来很开心。他说:\"${message}\" 我应该以开心温暖的语气回应。`\n          break\n        case 'sad':\n          prompt = `用户看起来有些伤心。他说:\"${message}\" 我应该以安慰关心的语气回应。`\n          break\n        case 'excited':\n          prompt = `用户看起来很兴奋。他说:\"${message}\" 我应该以热情积极的语气回应。`\n          break\n        case 'angry':\n          prompt = `用户看起来有些生气。他说:\"${message}\" 我应该以冷静理解的语气回应。`\n          break\n        default:\n          prompt = `用户说:\"${message}\" 请以友好自然的语气回应。`\n      }\n      \n      // 添加角色设定\n      prompt = `你是一个叫糖球的可爱助手，有着甜甜的性格和温暖的对话风格。\n你应该像个知心朋友一样回应用户，使用可爱的语气，偶尔加入一些轻松的表情。\n不需要过于正式，而是保持亲切友好的态度。注意你的回答要简洁，不要太长。\n${prompt}`\n      \n      // 发送到API并获取回复\n      return await service.sendMessage(prompt)\n    } catch (error) {\n      console.error('生成回复失败:', error)\n      throw error\n    }\n  }\n}\n\nexport default SparkService"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}