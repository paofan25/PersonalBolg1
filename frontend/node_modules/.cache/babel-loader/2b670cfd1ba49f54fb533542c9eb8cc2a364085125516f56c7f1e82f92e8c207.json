{"ast":null,"code":"import \"core-js/modules/web.dom-exception.stack.js\";\nimport CryptoJS from 'crypto-js';\nclass SparkService {\n  constructor() {\n    // 配置详情\n    this.appId = '5d2cf0e9';\n    this.apiKey = '2d6fa73a9d8d53a0b36ffdc71b1ce8a1';\n    this.apiSecret = 'ZGQwYzM1MWIxOTlmMmY1NWExY2E2Nzdk';\n    this.apiUrl = 'wss://spark-api.xf-yun.com/v2.1/chat';\n    this.websocket = null;\n    this.onMessageCallback = null;\n    this.onErrorCallback = null;\n  }\n\n  // 生成鉴权URL\n  generateAuthUrl() {\n    const host = 'spark-api.xf-yun.com/v2.1/chat';\n    const date = new Date().toUTCString();\n    const algorithm = 'hmac-sha256';\n    const headers = 'host date request-line';\n    const requestLine = 'GET /v2.1/chat HTTP/1.1';\n    const signatureOrigin = `host: ${host}\\ndate: ${date}\\n${requestLine}`;\n\n    // 使用CryptoJS计算签名\n    const signatureSha = CryptoJS.HmacSHA256(signatureOrigin, this.apiSecret);\n    const signature = CryptoJS.enc.Base64.stringify(signatureSha);\n\n    // 构造认证信息\n    const authorizationOrigin = `api_key=\"${this.apiKey}\", algorithm=\"${algorithm}\", headers=\"${headers}\", signature=\"${signature}\"`;\n\n    // 使用Base64编码认证信息\n    const authorization = btoa(authorizationOrigin);\n\n    // 构造URL\n    return `${this.parseApiUrl()}?authorization=${authorization}&date=${encodeURIComponent(date)}&host=${host}`;\n  }\n\n  // 转换API URL为WebSocket URL\n  parseApiUrl() {\n    // 替换http(s)为ws(s)\n    return this.apiUrl.replace(/^http/, 'ws');\n  }\n\n  // 发送消息\n  sendMessage(message) {\n    return new Promise((resolve, reject) => {\n      try {\n        console.log('准备发送消息:', message);\n\n        // 关闭现有连接\n        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n          this.websocket.close();\n        }\n\n        // 生成认证URL\n        const authUrl = this.generateAuthUrl();\n        console.log('认证URL生成成功');\n\n        // 创建WebSocket连接\n        this.websocket = new WebSocket(authUrl);\n        let responseText = '';\n\n        // 连接打开时的处理\n        this.websocket.onopen = () => {\n          console.log('WebSocket连接已建立');\n          // 发送消息\n          const messageJson = JSON.stringify(this.formatPrompt(message));\n          this.websocket.send(messageJson);\n          console.log('消息已发送:', messageJson);\n        };\n\n        // 接收消息的处理\n        this.websocket.onmessage = event => {\n          try {\n            const response = JSON.parse(event.data);\n            console.log('收到响应:', response);\n            if (response.header.code !== 0) {\n              console.error('API返回错误:', response.header.message);\n              reject(new Error(`API错误: ${response.header.code} - ${response.header.message}`));\n              this.websocket.close();\n              return;\n            }\n            const choices = response.payload.choices;\n            responseText += choices.text[0].content;\n\n            // 如果响应结束\n            if (choices.status === 2) {\n              console.log('对话完成,最终响应:', responseText);\n              resolve(responseText);\n              this.websocket.close();\n            }\n          } catch (error) {\n            console.error('处理响应消息失败:', error, event.data);\n            reject(error);\n            this.websocket.close();\n          }\n        };\n\n        // 错误处理\n        this.websocket.onerror = error => {\n          console.error('WebSocket错误:', error);\n          reject(error);\n        };\n\n        // 连接关闭处理\n        this.websocket.onclose = event => {\n          console.log('WebSocket连接已关闭:', event.code, event.reason);\n          if (!responseText && event.code !== 1000) {\n            reject(new Error(`WebSocket连接关闭: ${event.code} ${event.reason}`));\n          }\n        };\n      } catch (error) {\n        console.error('发送消息失败:', error);\n        reject(error);\n      }\n    });\n  }\n\n  // 格式化提示信息\n  formatPrompt(message) {\n    return {\n      header: {\n        app_id: this.appId,\n        uid: 'user_' + Date.now()\n      },\n      parameter: {\n        chat: {\n          domain: 'general',\n          temperature: 0.7,\n          max_tokens: 1024\n        }\n      },\n      payload: {\n        message: {\n          text: [{\n            role: 'system',\n            content: '你是糖球助手，一个可爱、乐于助人的AI助手。你的性格活泼开朗，对用户友好有礼貌。你正在与用户进行对话。请根据用户的提问提供简短、友好的回答，并在回答中体现活泼可爱的性格特点。对于你不知道的问题，请诚实地告诉用户你不知道。'\n          }, {\n            role: 'user',\n            content: message\n          }]\n        }\n      }\n    };\n  }\n\n  // 生成响应（结合情感分析）\n  async generateResponse(message, emotion) {\n    try {\n      let prompt = message;\n\n      // 根据情感调整系统提示\n      if (emotion && emotion !== 'neutral') {\n        const emotionPrompts = {\n          happy: '用户看起来心情很好，你的回答也应该保持积极欢快的语调。',\n          sad: '用户似乎有些难过，你的回答应该温暖、安慰人心。',\n          angry: '用户可能有些生气，你的回答应该平静、理解，避免激怒用户。',\n          surprised: '用户感到惊讶，你的回答可以表达共鸣并提供更多信息。',\n          scared: '用户可能感到担忧或害怕，你的回答应该令人安心，提供支持。'\n        };\n        prompt = `${emotionPrompts[emotion] || ''} ${message}`;\n      }\n      console.log('发送到Spark的消息:', prompt);\n      const response = await this.sendMessage(prompt);\n      return response || '对不起，我暂时无法回答这个问题。';\n    } catch (error) {\n      console.error('生成响应失败:', error);\n      throw error;\n    }\n  }\n}\nexport default new SparkService();","map":{"version":3,"names":["CryptoJS","SparkService","constructor","appId","apiKey","apiSecret","apiUrl","websocket","onMessageCallback","onErrorCallback","generateAuthUrl","host","date","Date","toUTCString","algorithm","headers","requestLine","signatureOrigin","signatureSha","HmacSHA256","signature","enc","Base64","stringify","authorizationOrigin","authorization","btoa","parseApiUrl","encodeURIComponent","replace","sendMessage","message","Promise","resolve","reject","console","log","readyState","WebSocket","OPEN","close","authUrl","responseText","onopen","messageJson","JSON","formatPrompt","send","onmessage","event","response","parse","data","header","code","error","Error","choices","payload","text","content","status","onerror","onclose","reason","app_id","uid","now","parameter","chat","domain","temperature","max_tokens","role","generateResponse","emotion","prompt","emotionPrompts","happy","sad","angry","surprised","scared"],"sources":["E:/code/PersonalBolg1/frontend/src/services/sparkAI.js"],"sourcesContent":["import CryptoJS from 'crypto-js'\n\nclass SparkService {\n  constructor() {\n    // 配置详情\n    this.appId = '5d2cf0e9'\n    this.apiKey = '2d6fa73a9d8d53a0b36ffdc71b1ce8a1'\n    this.apiSecret = 'ZGQwYzM1MWIxOTlmMmY1NWExY2E2Nzdk'\n    this.apiUrl = 'wss://spark-api.xf-yun.com/v2.1/chat'\n    \n    this.websocket = null\n    this.onMessageCallback = null\n    this.onErrorCallback = null\n  }\n\n  // 生成鉴权URL\n  generateAuthUrl() {\n    const host = 'spark-api.xf-yun.com/v2.1/chat'\n    const date = new Date().toUTCString()\n    const algorithm = 'hmac-sha256'\n    const headers = 'host date request-line'\n    const requestLine = 'GET /v2.1/chat HTTP/1.1'\n    const signatureOrigin = `host: ${host}\\ndate: ${date}\\n${requestLine}`\n    \n    // 使用CryptoJS计算签名\n    const signatureSha = CryptoJS.HmacSHA256(signatureOrigin, this.apiSecret)\n    const signature = CryptoJS.enc.Base64.stringify(signatureSha)\n    \n    // 构造认证信息\n    const authorizationOrigin = `api_key=\"${this.apiKey}\", algorithm=\"${algorithm}\", headers=\"${headers}\", signature=\"${signature}\"`\n    \n    // 使用Base64编码认证信息\n    const authorization = btoa(authorizationOrigin)\n    \n    // 构造URL\n    return `${this.parseApiUrl()}?authorization=${authorization}&date=${encodeURIComponent(date)}&host=${host}`\n  }\n\n  // 转换API URL为WebSocket URL\n  parseApiUrl() {\n    // 替换http(s)为ws(s)\n    return this.apiUrl.replace(/^http/, 'ws')\n  }\n\n  // 发送消息\n  sendMessage(message) {\n    return new Promise((resolve, reject) => {\n      try {\n        console.log('准备发送消息:', message)\n        \n        // 关闭现有连接\n        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n          this.websocket.close()\n        }\n        \n        // 生成认证URL\n        const authUrl = this.generateAuthUrl()\n        console.log('认证URL生成成功')\n        \n        // 创建WebSocket连接\n        this.websocket = new WebSocket(authUrl)\n        let responseText = ''\n        \n        // 连接打开时的处理\n        this.websocket.onopen = () => {\n          console.log('WebSocket连接已建立')\n          // 发送消息\n          const messageJson = JSON.stringify(this.formatPrompt(message))\n          this.websocket.send(messageJson)\n          console.log('消息已发送:', messageJson)\n        }\n        \n        // 接收消息的处理\n        this.websocket.onmessage = (event) => {\n          try {\n            const response = JSON.parse(event.data)\n            console.log('收到响应:', response)\n            \n            if (response.header.code !== 0) {\n              console.error('API返回错误:', response.header.message)\n              reject(new Error(`API错误: ${response.header.code} - ${response.header.message}`))\n              this.websocket.close()\n              return\n            }\n            \n            const choices = response.payload.choices\n            responseText += choices.text[0].content\n            \n            // 如果响应结束\n            if (choices.status === 2) {\n              console.log('对话完成,最终响应:', responseText)\n              resolve(responseText)\n              this.websocket.close()\n            }\n          } catch (error) {\n            console.error('处理响应消息失败:', error, event.data)\n            reject(error)\n            this.websocket.close()\n          }\n        }\n        \n        // 错误处理\n        this.websocket.onerror = (error) => {\n          console.error('WebSocket错误:', error)\n          reject(error)\n        }\n        \n        // 连接关闭处理\n        this.websocket.onclose = (event) => {\n          console.log('WebSocket连接已关闭:', event.code, event.reason)\n          if (!responseText && event.code !== 1000) {\n            reject(new Error(`WebSocket连接关闭: ${event.code} ${event.reason}`))\n          }\n        }\n      } catch (error) {\n        console.error('发送消息失败:', error)\n        reject(error)\n      }\n    })\n  }\n\n  // 格式化提示信息\n  formatPrompt(message) {\n    return {\n      header: {\n        app_id: this.appId,\n        uid: 'user_' + Date.now()\n      },\n      parameter: {\n        chat: {\n          domain: 'general',\n          temperature: 0.7,\n          max_tokens: 1024\n        }\n      },\n      payload: {\n        message: {\n          text: [\n            {\n              role: 'system',\n              content: '你是糖球助手，一个可爱、乐于助人的AI助手。你的性格活泼开朗，对用户友好有礼貌。你正在与用户进行对话。请根据用户的提问提供简短、友好的回答，并在回答中体现活泼可爱的性格特点。对于你不知道的问题，请诚实地告诉用户你不知道。'\n            },\n            {\n              role: 'user',\n              content: message\n            }\n          ]\n        }\n      }\n    }\n  }\n\n  // 生成响应（结合情感分析）\n  async generateResponse(message, emotion) {\n    try {\n      let prompt = message\n      \n      // 根据情感调整系统提示\n      if (emotion && emotion !== 'neutral') {\n        const emotionPrompts = {\n          happy: '用户看起来心情很好，你的回答也应该保持积极欢快的语调。',\n          sad: '用户似乎有些难过，你的回答应该温暖、安慰人心。',\n          angry: '用户可能有些生气，你的回答应该平静、理解，避免激怒用户。',\n          surprised: '用户感到惊讶，你的回答可以表达共鸣并提供更多信息。',\n          scared: '用户可能感到担忧或害怕，你的回答应该令人安心，提供支持。'\n        }\n        \n        prompt = `${emotionPrompts[emotion] || ''} ${message}`\n      }\n      \n      console.log('发送到Spark的消息:', prompt)\n      const response = await this.sendMessage(prompt)\n      return response || '对不起，我暂时无法回答这个问题。'\n    } catch (error) {\n      console.error('生成响应失败:', error)\n      throw error\n    }\n  }\n}\n\nexport default new SparkService()"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}