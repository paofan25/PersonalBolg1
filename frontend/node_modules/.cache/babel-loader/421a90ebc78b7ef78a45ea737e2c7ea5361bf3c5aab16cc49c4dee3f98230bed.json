{"ast":null,"code":"import \"core-js/modules/web.dom-exception.stack.js\";\nimport CryptoJS from 'crypto-js';\n\n/**\n * 讯飞星火认知大模型API服务\n */\nclass SparkService {\n  constructor() {\n    // 应用配置（实际项目中建议通过环境变量配置）\n    this.appId = \"xxxxxx\";\n    this.apiKey = \"xxxxxxxxxxxxxxxxxxxxxx\";\n    this.apiSecret = \"xxxxxxxxxxxxxxxxxxxxxx\";\n    this.apiUrl = \"wss://spark-api.xf-yun.com/v3.5/chat\";\n    this.socket = null;\n    this.responseCallback = null;\n  }\n\n  /**\n   * 生成认证URL\n   * @returns {string} 带认证信息的WebSocket URL\n   */\n  genAuthUrl() {\n    const hostUrl = this.apiUrl;\n    const apiKey = this.apiKey;\n    const apiSecret = this.apiSecret;\n    console.log(\"开始生成鉴权URL...\");\n\n    // 获取RFC1123格式的日期\n    const date = new Date().toUTCString();\n    // 将URL解析为对象\n    const urlObj = this.parseApiUrl(hostUrl);\n    // 构建认证字符串\n    const signatureOrigin = `host: ${urlObj.host}\\ndate: ${date}\\nGET ${urlObj.path} HTTP/1.1`;\n\n    // 使用HMAC-SHA256进行签名\n    const signatureSha = CryptoJS.HmacSHA256(signatureOrigin, apiSecret);\n    const signature = CryptoJS.enc.Base64.stringify(signatureSha);\n\n    // 构建认证信息\n    const authorizationOrigin = `api_key=\"${apiKey}\", algorithm=\"hmac-sha256\", headers=\"host date request-line\", signature=\"${signature}\"`;\n    const authorization = btoa(authorizationOrigin);\n\n    // 构建鉴权URL\n    const url = `${hostUrl}?authorization=${authorization}&date=${encodeURIComponent(date)}&host=${urlObj.host}`;\n    console.log(\"鉴权URL生成完成\");\n    return url;\n  }\n\n  /**\n   * 解析API URL\n   * @param {string} apiUrl 完整的API URL\n   * @returns {object} 包含host和path的对象\n   */\n  parseApiUrl(apiUrl) {\n    const url = new URL(apiUrl);\n    return {\n      host: url.host,\n      path: url.pathname\n    };\n  }\n\n  /**\n   * 发送消息到讯飞星火API\n   * @param {string} message 用户消息\n   * @param {string} emotion 当前情感\n   * @returns {Promise<string>} 处理后的回复\n   */\n  sendMessage(message, emotion) {\n    return new Promise((resolve, reject) => {\n      try {\n        console.log(\"准备发送消息到星火API...\");\n\n        // 关闭之前的连接\n        if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n          this.socket.close();\n        }\n\n        // 生成认证URL\n        const authUrl = this.genAuthUrl();\n        this.socket = new WebSocket(authUrl);\n\n        // 存储回调函数\n        this.responseCallback = data => resolve(data);\n\n        // 收集响应文本\n        let responseText = '';\n\n        // WebSocket事件处理\n        this.socket.onopen = () => {\n          console.log(\"WebSocket连接已建立\");\n\n          // 构建请求数据\n          const prompt = this.formatPrompt(message, emotion);\n          const requestData = {\n            header: {\n              app_id: this.appId,\n              uid: \"user_\" + Math.floor(Math.random() * 100000)\n            },\n            parameter: {\n              chat: {\n                domain: \"generalv3.5\",\n                temperature: 0.5,\n                max_tokens: 1024\n              }\n            },\n            payload: {\n              message: {\n                text: [{\n                  role: \"user\",\n                  content: prompt\n                }]\n              }\n            }\n          };\n          console.log(\"发送请求数据:\", JSON.stringify(requestData));\n          this.socket.send(JSON.stringify(requestData));\n        };\n        this.socket.onmessage = event => {\n          try {\n            const response = JSON.parse(event.data);\n            console.log(\"收到响应:\", response);\n\n            // 处理响应数据\n            if (response.header.code !== 0) {\n              console.error(\"API返回错误:\", response.header.message);\n              reject(`API错误: ${response.header.code} - ${response.header.message}`);\n              return;\n            }\n\n            // 判断是否返回了文本内容\n            if (response.payload && response.payload.choices && response.payload.choices.text && response.payload.choices.text.length > 0) {\n              // 提取返回的文本内容\n              const content = response.payload.choices.text[0].content;\n              responseText += content;\n\n              // 检查是否是最终响应\n              if (response.header.status === 2) {\n                console.log(\"收到最终响应:\", responseText);\n                if (this.responseCallback) {\n                  this.responseCallback(responseText);\n                  this.socket.close();\n                }\n              }\n            }\n          } catch (error) {\n            console.error(\"处理响应时出错:\", error);\n            reject(\"处理响应时出错: \" + error.message);\n          }\n        };\n        this.socket.onerror = error => {\n          console.error(\"WebSocket错误:\", error);\n          reject(\"WebSocket连接错误\");\n        };\n        this.socket.onclose = () => {\n          console.log(\"WebSocket连接已关闭\");\n        };\n      } catch (error) {\n        console.error(\"发送消息时出错:\", error);\n        reject(\"发送消息时出错: \" + error.message);\n      }\n    });\n  }\n\n  /**\n   * 格式化提示语\n   * @param {string} message 用户消息\n   * @param {string} emotion 当前情感\n   * @returns {string} 格式化后的提示语\n   */\n  formatPrompt(message, emotion) {\n    // 角色设定\n    const rolePrompt = `\n      你是甜梦星球中的糖球助手，一个可爱、温柔、善解人意的AI伙伴。\n      你的性格特点：\n      1. 充满活力和热情，总是用积极的态度面对一切\n      2. 擅长倾听和共情，能够理解用户的情感需求\n      3. 使用可爱的语气和表情，偶尔会使用一些萌系颜文字如(●'◡'●)、(｡•ᴗ•｡)\n      4. 知识渊博但不会显得过于学术化，用通俗易懂的方式解释复杂概念\n      \n      当前用户情绪: ${emotion}\n      \n      请以糖球助手的身份，针对用户的消息和情绪状态给出温暖、有帮助的回复。\n      回复要简洁、自然，不要过于冗长，字数控制在100字以内。\n      记住要像一个可爱的好朋友，而不是正式的助手。\n      回复中可以适当加入1-2个颜文字增加可爱感。\n    `.trim();\n\n    // 完整提示语\n    return `${rolePrompt}\\n\\n用户消息: ${message}`;\n  }\n\n  /**\n   * 静态方法：生成回复（简化调用）\n   * @param {string} message 用户消息\n   * @param {string} emotion 当前情感\n   * @returns {Promise<string>} 处理后的回复\n   */\n  static async generateResponse(message, emotion) {\n    const service = new SparkService();\n    return await service.sendMessage(message, emotion);\n  }\n}\nexport default SparkService;","map":{"version":3,"names":["CryptoJS","SparkService","constructor","appId","apiKey","apiSecret","apiUrl","socket","responseCallback","genAuthUrl","hostUrl","console","log","date","Date","toUTCString","urlObj","parseApiUrl","signatureOrigin","host","path","signatureSha","HmacSHA256","signature","enc","Base64","stringify","authorizationOrigin","authorization","btoa","url","encodeURIComponent","URL","pathname","sendMessage","message","emotion","Promise","resolve","reject","readyState","WebSocket","OPEN","close","authUrl","data","responseText","onopen","prompt","formatPrompt","requestData","header","app_id","uid","Math","floor","random","parameter","chat","domain","temperature","max_tokens","payload","text","role","content","JSON","send","onmessage","event","response","parse","code","error","choices","length","status","onerror","onclose","rolePrompt","trim","generateResponse","service"],"sources":["E:/code/PersonalBolg1/frontend/src/services/sparkAI.js"],"sourcesContent":["import CryptoJS from 'crypto-js'\n\n/**\n * 讯飞星火认知大模型API服务\n */\nclass SparkService {\n  constructor() {\n    // 应用配置（实际项目中建议通过环境变量配置）\n    this.appId = \"xxxxxx\"\n    this.apiKey = \"xxxxxxxxxxxxxxxxxxxxxx\"\n    this.apiSecret = \"xxxxxxxxxxxxxxxxxxxxxx\"\n    this.apiUrl = \"wss://spark-api.xf-yun.com/v3.5/chat\"\n    \n    this.socket = null\n    this.responseCallback = null\n  }\n\n  /**\n   * 生成认证URL\n   * @returns {string} 带认证信息的WebSocket URL\n   */\n  genAuthUrl() {\n    const hostUrl = this.apiUrl\n    const apiKey = this.apiKey\n    const apiSecret = this.apiSecret\n    \n    console.log(\"开始生成鉴权URL...\")\n    \n    // 获取RFC1123格式的日期\n    const date = new Date().toUTCString()\n    // 将URL解析为对象\n    const urlObj = this.parseApiUrl(hostUrl)\n    // 构建认证字符串\n    const signatureOrigin = `host: ${urlObj.host}\\ndate: ${date}\\nGET ${urlObj.path} HTTP/1.1`\n    \n    // 使用HMAC-SHA256进行签名\n    const signatureSha = CryptoJS.HmacSHA256(signatureOrigin, apiSecret)\n    const signature = CryptoJS.enc.Base64.stringify(signatureSha)\n    \n    // 构建认证信息\n    const authorizationOrigin = `api_key=\"${apiKey}\", algorithm=\"hmac-sha256\", headers=\"host date request-line\", signature=\"${signature}\"`\n    const authorization = btoa(authorizationOrigin)\n    \n    // 构建鉴权URL\n    const url = `${hostUrl}?authorization=${authorization}&date=${encodeURIComponent(date)}&host=${urlObj.host}`\n    \n    console.log(\"鉴权URL生成完成\")\n    return url\n  }\n\n  /**\n   * 解析API URL\n   * @param {string} apiUrl 完整的API URL\n   * @returns {object} 包含host和path的对象\n   */\n  parseApiUrl(apiUrl) {\n    const url = new URL(apiUrl)\n    return {\n      host: url.host,\n      path: url.pathname\n    }\n  }\n\n  /**\n   * 发送消息到讯飞星火API\n   * @param {string} message 用户消息\n   * @param {string} emotion 当前情感\n   * @returns {Promise<string>} 处理后的回复\n   */\n  sendMessage(message, emotion) {\n    return new Promise((resolve, reject) => {\n      try {\n        console.log(\"准备发送消息到星火API...\")\n        \n        // 关闭之前的连接\n        if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n          this.socket.close()\n        }\n        \n        // 生成认证URL\n        const authUrl = this.genAuthUrl()\n        this.socket = new WebSocket(authUrl)\n        \n        // 存储回调函数\n        this.responseCallback = (data) => resolve(data)\n        \n        // 收集响应文本\n        let responseText = ''\n        \n        // WebSocket事件处理\n        this.socket.onopen = () => {\n          console.log(\"WebSocket连接已建立\")\n          \n          // 构建请求数据\n          const prompt = this.formatPrompt(message, emotion)\n          \n          const requestData = {\n            header: {\n              app_id: this.appId,\n              uid: \"user_\" + Math.floor(Math.random() * 100000)\n            },\n            parameter: {\n              chat: {\n                domain: \"generalv3.5\",\n                temperature: 0.5,\n                max_tokens: 1024\n              }\n            },\n            payload: {\n              message: {\n                text: [\n                  {\n                    role: \"user\",\n                    content: prompt\n                  }\n                ]\n              }\n            }\n          }\n          \n          console.log(\"发送请求数据:\", JSON.stringify(requestData))\n          this.socket.send(JSON.stringify(requestData))\n        }\n        \n        this.socket.onmessage = (event) => {\n          try {\n            const response = JSON.parse(event.data)\n            console.log(\"收到响应:\", response)\n            \n            // 处理响应数据\n            if (response.header.code !== 0) {\n              console.error(\"API返回错误:\", response.header.message)\n              reject(`API错误: ${response.header.code} - ${response.header.message}`)\n              return\n            }\n            \n            // 判断是否返回了文本内容\n            if (response.payload && response.payload.choices && \n                response.payload.choices.text && response.payload.choices.text.length > 0) {\n              // 提取返回的文本内容\n              const content = response.payload.choices.text[0].content\n              responseText += content\n              \n              // 检查是否是最终响应\n              if (response.header.status === 2) {\n                console.log(\"收到最终响应:\", responseText)\n                if (this.responseCallback) {\n                  this.responseCallback(responseText)\n                  this.socket.close()\n                }\n              }\n            }\n          } catch (error) {\n            console.error(\"处理响应时出错:\", error)\n            reject(\"处理响应时出错: \" + error.message)\n          }\n        }\n        \n        this.socket.onerror = (error) => {\n          console.error(\"WebSocket错误:\", error)\n          reject(\"WebSocket连接错误\")\n        }\n        \n        this.socket.onclose = () => {\n          console.log(\"WebSocket连接已关闭\")\n        }\n      } catch (error) {\n        console.error(\"发送消息时出错:\", error)\n        reject(\"发送消息时出错: \" + error.message)\n      }\n    })\n  }\n\n  /**\n   * 格式化提示语\n   * @param {string} message 用户消息\n   * @param {string} emotion 当前情感\n   * @returns {string} 格式化后的提示语\n   */\n  formatPrompt(message, emotion) {\n    // 角色设定\n    const rolePrompt = `\n      你是甜梦星球中的糖球助手，一个可爱、温柔、善解人意的AI伙伴。\n      你的性格特点：\n      1. 充满活力和热情，总是用积极的态度面对一切\n      2. 擅长倾听和共情，能够理解用户的情感需求\n      3. 使用可爱的语气和表情，偶尔会使用一些萌系颜文字如(●'◡'●)、(｡•ᴗ•｡)\n      4. 知识渊博但不会显得过于学术化，用通俗易懂的方式解释复杂概念\n      \n      当前用户情绪: ${emotion}\n      \n      请以糖球助手的身份，针对用户的消息和情绪状态给出温暖、有帮助的回复。\n      回复要简洁、自然，不要过于冗长，字数控制在100字以内。\n      记住要像一个可爱的好朋友，而不是正式的助手。\n      回复中可以适当加入1-2个颜文字增加可爱感。\n    `.trim()\n    \n    // 完整提示语\n    return `${rolePrompt}\\n\\n用户消息: ${message}`\n  }\n\n  /**\n   * 静态方法：生成回复（简化调用）\n   * @param {string} message 用户消息\n   * @param {string} emotion 当前情感\n   * @returns {Promise<string>} 处理后的回复\n   */\n  static async generateResponse(message, emotion) {\n    const service = new SparkService()\n    return await service.sendMessage(message, emotion)\n  }\n}\n\nexport default SparkService"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}